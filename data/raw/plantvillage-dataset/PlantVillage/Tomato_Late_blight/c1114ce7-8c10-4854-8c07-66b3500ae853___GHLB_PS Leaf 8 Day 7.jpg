if dirFlg == 1:
                    tup = (vA, tup[1])
                else:
                    tup = (tup[0], vB)
                self.closedGap = True
            else:
                gap = round(gap, 6)
                if gap < self.gaps[0]:
                    self.gaps.insert(0, gap)
                    self.gaps.pop()
        inLine.append(tup)
    # Efor
    lnCnt += 1

    # Fix directional issue with LAST line when line count is even
    isEven = lnCnt % 2
    if isEven == 0:  #  Changed to != with 90 degree CutPatternAngle
        PathLog.debug("Line count is even: {}.".format(lnCnt))
    else:
        PathLog.debug("Line count is ODD: {}.".format(lnCnt))
        dirFlg = -1 * dirFlg
        if not obj.CutPatternReversed:
            if self.CutClimb:
                dirFlg = -1 * dirFlg

    if obj.CutPatternReversed:
        dirFlg = -1 * dirFlg

    # Handle last inLine list
    if dirFlg == 1:
        rev = []
        for iL in inLine:
            if iL == "BRK":
                rev.append(iL)
            else:
                (p1, p2) = iL
                rev.append((p2, p1))

        if not obj.CutPatternReversed:
            rev.reverse()
        else:
            rev2 = []
            for iL in rev:
                if iL == "BRK":
                    rev2.append(iL)
                else:
                    (p1, p2) = iL
                    rev2.append((p2, p1))
            rev2.reverse()
            rev = rev2
        LINES.append(rev)
    else:
        LINES.append(inLine)

    return LINES


def pathGeomToCircularPointSet(self, obj, compGeoShp):
    """pathGeomToCircularPointSet(self, obj, compGeoShp)...
    Convert a compound set of arcs/circles to a set of directionally-oriented arc end points
    and the corresponding center point."""
    # Extract intersection line segments for return value as []
    PathLog.debug("pathGeomToCircularPointSet()")
    ARCS = []
    stpOvrEI = []
    segEI = []
    isSame = False
    sameRad = None
    ec = len(compGeoShp.Edges)

    def gapDist(sp, ep):
        X = (ep[0] - sp[0]) ** 2
        Y = (ep[1] - sp[1]) ** 2
        return math.sqrt(X + Y)  # the 'z' value is zero in both points

    def dist_to_cent(item):
        # Sort incoming arcs by distance to center
        # item: edge type, direction flag, parts tuple
        # parts: start tuple, end tuple, center tuple
        s = item[2][0][0]
        p1 = FreeCAD.Vector(s[0], s[1], 0.0)
        e = item[2][0][2]
        p2 = FreeCAD.Vector(e[0], e[1], 0.0)
        return p1.sub(p2).Length

    if obj.CutPatternReversed:
        if self.CutClimb:
            self.CutClimb = False
        else:
            self.CutClimb = True

    # Separate arc data into Loops and Arcs
    for ei in range(0, ec):
        edg = compGeoShp.Edges[ei]
        if edg.Closed is True:
            stpOvrEI.append(("L", ei, False))
        else:
            if isSame is False:
                segEI.append(ei)
                isSame = True
                pnt = FreeCAD.Vector(edg.Vertexes[0].X, edg.Vertexes[0].Y, 0.0)
                sameRad = pnt.sub(self.tmpCOM).Length
            else:
                # Check if arc is co-radial to current SEGS
                pnt = FreeCAD.Vector(edg.Vertexes[0].X, edg.Vertexes[0].Y, 0.0)
                if abs(sameRad - pnt.sub(self.tmpCOM).Length) > 0.00001:
                    isSame = False

                if isSame is True:
                    segEI.append(ei)
                else:
                    # Move co-radial arc segments
                    stpOvrEI.append(["A", segEI, False])
                    # Start new list of arc segments
                    segEI = [ei]
                    isSame = True
                    pnt = FreeCAD.Vector(edg.Vertexes[0].X, edg.Vertexes[0].Y, 0.0)
                    sameRad = pnt.sub(self.tmpCOM).Length
    # Process trailing `segEI` data, if available
    if isSame is True:
        stpOvrEI.append(["A", segEI, False])

    # Identify adjacent arcs with y=0 start/end points that connect
    for so in range(0, len(stpOvrEI)):
        SO = stpOvrEI[so]
        if SO[0] == "A":
            startOnAxis = []
            endOnAxis = []
            EI = SO[1]  # list of corresponding compGeoShp.Edges indexes

            # Identify startOnAxis and endOnAxis arcs
            for i in range(0, len(EI)):
                ei = EI[i]  # edge index
                E = compGeoShp.Edges[ei]  # edge object
                if abs(self.tmpCOM.y - E.Vertexes[0].Y) < 0.00001:
                    startOnAxis.append((i, ei, E.Vertexes[0]))
                elif abs(self.tmpCOM.y - E.Vertexes[1].Y) < 0.00001:
                    endOnAxis.append((i, ei, E.Vertexes[1]))

            # Look for connections between startOnAxis and endOnAxis arcs. Consolidate data when connected
            lenSOA = len(startOnAxis)
            lenEOA = len(endOnAxis)
            if lenSOA > 0 and lenEOA > 0:
                for soa in range(0, lenSOA):
                    (iS, eiS, vS) = startOnAxis[soa]
                    for eoa in range(0, len(endOnAxis)):
                        (iE, eiE, vE) = endOnAxis[eoa]
                        dist = vE.X - vS.X
                        if abs(dist) < 0.00001:  # They connect on axis at same radius
                            SO[2] = (eiE, eiS)
                            break
                        elif dist > 0:
                            break  # stop searching
            # Eif
        # Eif
    # Efor

    # Construct arc data tuples for OCL
    dirFlg = 1
    if not self.CutClimb:  # True yields Climb when set to Conventional
        dirFlg = -1

    # Declare center point of circle pattern
    cp = (self.tmpCOM.x, self.tmpCOM.y, 0.0)

    # Cycle through stepOver data
    for so in range(0, len(stpOvrEI)):
        SO = stpOvrEI[so]
        if SO[0] == "L":  # L = Loop/Ring/Circle
            # PathLog.debug("SO[0] == 'Loop'")
            lei = SO[1]  # loop Edges index
            v1 = compGeoShp.Edges[lei].Vertexes[0]

            # space = obj.SampleInterval.Value / 10.0
            # space = 0.000001
            space = (
                self.toolDiam * 0.005
            )  # If too small, OCL will fail to scan the loop

            # p1 = FreeCAD.Vector(v1.X, v1.Y, v1.Z)
            p1 = FreeCAD.Vector(
                v1.X, v1.Y, 0.0
            )  # z=0.0 for waterline; z=v1.Z for 3D Surface
            rad = p1.sub(self.tmpCOM).Length
            spcRadRatio = space / rad
            if spcRadRatio < 1.0:
                tolrncAng = math.asin(spcRadRatio)
            else:
                tolrncAng = 0.99999998 * math.pi
            EX = self.tmpCOM.x + (rad * math.cos(tolrncAng))
            EY = v1.Y - space  # rad * ma